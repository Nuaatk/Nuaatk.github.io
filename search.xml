<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何上传本地项目到GitHub</title>
    <url>/2023/06/17/github%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="上传本地项目到Github"><a href="#上传本地项目到Github" class="headerlink" title="上传本地项目到Github"></a>上传本地项目到Github</h1><h3 id="第一步：安装Git"><a href="#第一步：安装Git" class="headerlink" title="第一步：安装Git"></a>第一步：安装Git</h3><h3 id="第二步：创建文件夹"><a href="#第二步：创建文件夹" class="headerlink" title="第二步：创建文件夹"></a>第二步：创建文件夹</h3><p>创建一个本地项目所在的文件夹</p>
<p>然后右击<code>Git bash</code>在该文件夹目录下打开Git终端</p>
<h3 id="第三步：git-init"><a href="#第三步：git-init" class="headerlink" title="第三步：git init"></a>第三步：git init</h3><p>在命令行中输入<code>git init</code>使得该文件夹变成一个可由git管理的仓库</p>
<h3 id="第四步：git-add"><a href="#第四步：git-add" class="headerlink" title="第四步：git add ."></a>第四步：git add .</h3><p>在命令行中输入<code>git add .</code>将该文件夹所有的文件添加到缓存区</p>
<h3 id="第五步：git-commit-m"><a href="#第五步：git-commit-m" class="headerlink" title="第五步：git commit -m"></a>第五步：git commit -m</h3><p>使用命令<code>git commit -m &quot;commit的备注信息&quot;</code></p>
<h3 id="第六步：关联github与本地仓库"><a href="#第六步：关联github与本地仓库" class="headerlink" title="第六步：关联github与本地仓库"></a>第六步：关联github与本地仓库</h3><p>此步骤仅需要进行一次，输入<code>git remote add origin https://github.com/.git你自己的github网址</code></p>
<p>首先在github创建一个空项目。复制https，即为本项目所上传到的网址</p>
<p>如果想要免密登录需要在config里设置用户邮箱和github一致 </p>
<p>并在gihub账户端设置ssh的公钥</p>
<p>这两步缺一都需要输入密码才能关联</p>
<h3 id="第七步：git-push-origin-master"><a href="#第七步：git-push-origin-master" class="headerlink" title="第七步：git push origin master"></a>第七步：git push origin master</h3><p>输入命令<code>git push origin master</code>将本地仓库推送到GitHub中</p>
<p>第一次上传添加 -u</p>
]]></content>
  </entry>
  <entry>
    <title>DDR重要时序参数</title>
    <url>/2023/06/17/DDR%E9%87%8D%E8%A6%81%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="DRAM时序"><a href="#DRAM时序" class="headerlink" title="DRAM时序"></a>DRAM时序</h1><img  
                     lazyload
                     alt="image"
                     data-src="/2023/06/17/DDR%E9%87%8D%E8%A6%81%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0/DDR.png"
                      class="" title="DDR"
                >



<ul>
<li>tCK：指的是DRAM内部时钟的周期时间。</li>
<li>CL：读取命令发出后到从列地址读出数据到IO接口的间隔时间。列地址代表了内存cell的比特线，是内存cell中实际发生读写操作的接口，换句话说就是列地址连接着储存数据信息的电容，写入时电荷从列地址流向电容，读取时电荷从电容流向列地址，并输出到DQ引脚 </li>
<li>AL：从DDR2起，RAS指令后可以马上接CAS指令，但比起传统的RAS后等tRCD再发送CAS的方式，数据能够从阵列中读出的延时并不能间断，AL就是用来表征这段额外延时</li>
</ul>
<p>​		如果采取RAS指令马上接CAS指令的方式，AL&#x3D;tRCD-1，如果等tRCD再接CAS指令，则不		用计算AL ;RL&#x3D;(CL+AL)</p>
<ul>
<li><p>RL：Read Latency，总的读延迟，RL &#x3D; AL + CL</p>
</li>
<li><p>WL ：Wead Latency，总的写延迟，WL &#x3D; （RL - 1）&#x2F;&#x2F;AL + CWL</p>
</li>
<li><p>BL：Bus Latency&#x2F;burst lengths</p>
</li>
<li><p>tRAS:(Row Address Strobe)：RAS指令持续时间,tRAS可以理解为内存完成一个行、列地址激活操作的贤者时间，内存控制器从发出“ACT”指令激活行&#x2F;列地址后进行下一个指令必须等待一个完整的tRAS时钟周期，也就是tRAS包含了tRCD和CL的操作，所以tRAS通常大于等于tRCD+CL，尤其是在大容量内存上可以适当放宽tRAS时序，在tRCD+CL的基础上加多几个时钟周期有助于稳定性的提高。</p>
</li>
<li><p>tRCD：RAS to CAS Delay ,定义了内存控制器发出“ACT”指令激活某个Bank中的某一行地址所需要的时间，在完成tRCD后，内存才会接着发送列地址以及读写指令，进行读写操作。</p>
</li>
<li><p>tRRD：向不同Bank中同一行两次发送行地址的间隔，</p>
<p>定义的是连续激活两行地址的最低等待时钟周期，当内存进行频繁读写时，会连续激活行地址进行读写操作，tRRD就是连续激活两行地址所需的等待时钟周期 </p>
</li>
<li><p>tRC：行地址周期时间，定义的是内存完成行地址操作所需的时钟周期。tRC包括了tRAS和tRP两个操作，tRAS激活行地址，tRP完成预充电，tRC指的是完成整个行地址操作所需时间。 </p>
</li>
<li><p>tRP：Precharge time，定义的是在同一个Bank中，前一个行地址读写操作已经完成，准备对下一个行地址操作时，对下一个行地址进行的预充电。</p>
</li>
<li><p>tCCD：CAS和CAS最短间隔</p>
</li>
<li><p>tRTP：read to precharge，定义了控制器发出读取命令后到下一个预充电命令的延迟时间。</p>
</li>
<li><p>tWTR：write to read，定义了控制器发出写入命令后到读取命令的间隔时间。</p>
</li>
<li><p>tWR：写入恢复延迟，定义的是内存Bank中进行写入命令后需要等待多少个时钟周期，才能进行预充电命令和下一个操作。这个时序用于确保Bank中已激活的地址能将数据完整保存进内存cell的电容中。 </p>
</li>
<li><p>tRTRS：Rank-to-Rank Switching Time，从一个DRAM rank的访问到另一个DRAM rank的访问之间所需的最小延迟时间。ACTIVATE Timing</p>
</li>
<li><p>tRFC：刷新命令与其他命令（除DES命令）之间的延迟</p>
</li>
<li><p>tFAW：一个Rank中连续激活四个行地址所需要的时间（tFAW&gt;4tRRD）指在DRAM内存中，当内存控制器连续下达激活命令时，需要等待一定的时间，才能下达下第五个激活命令。tFAW指的是这个等待时间的长度，通常以时钟周期为单位。</p>
</li>
<li><p>tCKE：从关闭时钟使能信号到DRAM芯片进入休眠状态之间所需的最小延迟时间。</p>
</li>
<li><p>tXP：在DRAM中，tXP是指在DRAM退出断电模式后，CKE变为高电平后的时间，DRAM就可以执行有效的读写操作</p>
</li>
<li><p>tCMD：指的是DRAM控制器向DRAM芯片发送指令时所需的最小延迟时间。</p>
</li>
<li><p>CWL ：CAS Write latency，Column-Address-Strobe Write。写命令与第一个送出第一个写数据之间的延迟。</p>
</li>
<li><p>WL ：Wead Latency，总的写延迟，WL &#x3D; AL + CWL</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第一节：课程大纲</title>
    <url>/2024/05/01/%E6%96%AF%E5%9D%A6%E7%A6%8F1/</url>
    <content><![CDATA[<h3 id="第1节：课程大纲"><a href="#第1节：课程大纲" class="headerlink" title="第1节：课程大纲"></a>第1节：课程大纲</h3><p><strong>编程语言</strong></p>
<ul>
<li>C</li>
<li>Assembly</li>
<li>C++</li>
<li>Concurrent Programming</li>
<li>Scheme</li>
<li>Python</li>
</ul>
<p><strong>编程思想</strong></p>
<p>学习这些语言，更重要的是学习其背后的范式。即编程思想。 </p>
<ul>
<li><p>面向过程</p>
<p>面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。举个五子棋的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下五子棋&#123;</span><br><span class="line">开始游戏（）；</span><br><span class="line">黑子先走（）；</span><br><span class="line">绘制画面（）；</span><br><span class="line">判断输赢（）；</span><br><span class="line">轮到白子（）；</span><br><span class="line">绘制画面（）；</span><br><span class="line">判断输赢（）；</span><br><span class="line">返回到 黑子先走（）；</span><br><span class="line">输出最后结果；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>面向对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下五子棋&#123;</span><br><span class="line">开始游戏（）；</span><br><span class="line">选手.黑落子（）；</span><br><span class="line">棋盘系统.绘制（）；</span><br><span class="line">规则系统.判断（）；</span><br><span class="line">选手.白落子（）；</span><br><span class="line">棋盘系统.绘制（）；</span><br><span class="line">规则系统.判断（）；</span><br><span class="line">循环到输出结果；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发编程</p>
</li>
<li><p>函数式编程</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第十节：栈与函数调用</title>
    <url>/2024/05/06/%E6%96%AF%E5%9D%A6%E7%A6%8F10/</url>
    <content><![CDATA[<h3 id="第10节：栈与函数调用"><a href="#第10节：栈与函数调用" class="headerlink" title="第10节：栈与函数调用"></a>第10节：栈与函数调用</h3><ul>
<li>函数传入的参数为什么还要保存到栈中呢。现代的编译器貌似并不是这么操作的</li>
</ul>
<p>​		riscv64-gcc是直接将参数传入a0,a1寄存器，然后调用函数，不需要再存到内存中去</p>
<ul>
<li>PC寄存器的值也需要保存，相当于riscv中的ra寄存器的作用&#x2F;&#x2F;不对</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数调用中栈的活动记录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> bar,<span class="type">int</span> * baz)</span>&#123;</span><br><span class="line">    <span class="type">char</span> snink[<span class="number">4</span>];</span><br><span class="line">    <span class="type">short</span> *why;</span><br><span class="line">    why=(<span class="type">short</span>*)(snink+<span class="number">2</span>);</span><br><span class="line">    *why=<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">4</span>;</span><br><span class="line">    foo(i,&amp;i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">main:</span><br><span class="line">SP=SP<span class="number">-4</span>;<span class="comment">//最开始SP指向栈顶,也就是第一个saved PC</span></span><br><span class="line">M[SP]=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//Params</span></span><br><span class="line">SP=SP<span class="number">-8</span>;</span><br><span class="line">R1=M[SP+<span class="number">8</span>];</span><br><span class="line">R2=SP+<span class="number">8</span>;</span><br><span class="line">M[SP]=R1;</span><br><span class="line">M[SP+<span class="number">4</span>]=R2;</span><br><span class="line">CALL&lt;foo&gt;;<span class="comment">//当call指令执行的时候，会自动将PC-4，并存起来，也就是第二个saved PC</span></span><br><span class="line">SP=SP+<span class="number">8</span>;</span><br><span class="line">RV=<span class="number">0</span>;</span><br><span class="line">foo:</span><br><span class="line">SP=SP<span class="number">-8</span>;</span><br><span class="line">R1=SP+<span class="number">6</span>;</span><br><span class="line">M[SP]=R1;</span><br><span class="line">R1=M[SP];</span><br><span class="line">M[R1]=<span class="number">.2</span> <span class="number">50</span>;</span><br><span class="line">sp=sp+<span class="number">8</span>;</span><br><span class="line">RET;<span class="comment">//与call类似，执行ret的时候也会将saved PC呢块地址自动的进行一个PC+4</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">┌───────────────┐</span><br><span class="line">│               │	argv</span><br><span class="line">├───────────────┤	</span><br><span class="line">│       <span class="number">2</span>       │	argc</span><br><span class="line">├───────────────┤</span><br><span class="line">│    saved PC   │	</span><br><span class="line">├───────────────┤</span><br><span class="line">│       <span class="number">4</span>       │	i</span><br><span class="line">├───────────────┤</span><br><span class="line">│      &amp;i       │	baz</span><br><span class="line">├───────────────┤</span><br><span class="line">│       <span class="number">4</span>       │	bar</span><br><span class="line">├───────────────┤</span><br><span class="line">│    saved PC   │	</span><br><span class="line">├───┼───┼───┼───┤</span><br><span class="line">│   │   │   │   │	snink[<span class="number">0</span>,,<span class="number">3</span>]</span><br><span class="line">├───┴───┴───┴───┤</span><br><span class="line">│               │	why</span><br><span class="line">└───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/06/%E6%96%AF%E5%9D%A6%E7%A6%8F10/1715912901808.png"
                      class="" width="1715912901808"
                >

<ul>
<li>从baz以后的变量控制权都交给了foo函数<br>baz和bar是传入参数，属于caller<br>sinik[]和why属于局部变量，属于callee<br>只有调用者才知道怎样将有意义的参数值写入内存，因此必须一个空间一个空间的申请，而不是直接全部由main函数申请。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归函数中栈的活动记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)return1;</span><br><span class="line">    <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">&lt;fact&gt;:</span><br><span class="line">R1=M[SP+<span class="number">4</span>];</span><br><span class="line">BNE R1,<span class="number">0</span>,PC+<span class="number">12</span>;<span class="comment">//PC指的就是当前这条指令，在有些情况下在执行BNE这条指令时PC已经+4了，这里假设PC不变</span></span><br><span class="line">RV=<span class="number">1</span>;</span><br><span class="line">RET;</span><br><span class="line">R1=M[SP+<span class="number">4</span>];</span><br><span class="line">R1=R1<span class="number">-1</span>;</span><br><span class="line">SP=SP<span class="number">-4</span>;</span><br><span class="line">M[SP]=R1;</span><br><span class="line">CALL&lt;fact&gt;;</span><br><span class="line">SP=SP+<span class="number">4</span>;</span><br><span class="line">R1=M[SP+<span class="number">4</span>];</span><br><span class="line">RV=RV*R1;</span><br></pre></td></tr></table></figure>

<p>call是一个占位符，在Linked其中会赋予真正的汇编代码含义。这样做的好处是不同文件一块编译的时候更加方便相对数值的计算</p>
]]></content>
  </entry>
  <entry>
    <title>解决hexo d 命令报错 Deploer not found git</title>
    <url>/2023/06/17/hexo%20d%20%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%20Deploer%20not%20found%20git/</url>
    <content><![CDATA[<h1 id="解决hexo-d-命令报错-Deploer-not-found-git"><a href="#解决hexo-d-命令报错-Deploer-not-found-git" class="headerlink" title="解决hexo d 命令报错 Deploer not found git"></a>解决hexo d 命令报错 Deploer not found git</h1><p>安装hexo-deployer-git</p>
<p>命令：</p>
<p><code>npm insatll --save hexo-deployer-git</code></p>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第十一节：指针与引用</title>
    <url>/2024/05/07/%E6%96%AF%E5%9D%A6%E7%A6%8F11/</url>
    <content><![CDATA[<h3 id="第11节：指针与引用"><a href="#第11节：指针与引用" class="headerlink" title="第11节：指针与引用"></a>第11节：指针与引用</h3><p><strong>swap的c和c++版本，来讲述指针如何在内存中实现。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    x=<span class="number">11</span>;</span><br><span class="line">    y=<span class="number">17</span>;</span><br><span class="line">    swap(&amp;x,&amp;y);<span class="comment">//swap(&amp;x,&amp;y); in c++</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">SP=SP<span class="number">-8</span>;</span><br><span class="line">M[SP+<span class="number">4</span>]=<span class="number">11</span>;</span><br><span class="line">M[SP]=<span class="number">17</span>;</span><br><span class="line">R1=SP;   <span class="comment">//&amp;y</span></span><br><span class="line">R2=SP+<span class="number">4</span>; <span class="comment">//&amp;x</span></span><br><span class="line">SP=SP<span class="number">-8</span>;</span><br><span class="line">M[SP]=R2;</span><br><span class="line">M[SP+<span class="number">4</span>]=R1;</span><br><span class="line">CALL &lt;swap&gt;;</span><br><span class="line">SP=SP+<span class="number">8</span>;</span><br><span class="line">RET;</span><br></pre></td></tr></table></figure>

<ul>
<li>c语言版本的SWAP</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *ap,<span class="type">int</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*ap;</span><br><span class="line">    *ap=*bp;</span><br><span class="line">    *bp=temp;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">&lt;swap&gt;:</span><br><span class="line">SP=SP<span class="number">-4</span>;</span><br><span class="line">R1=M[SP+<span class="number">8</span>];</span><br><span class="line">R2=M[R1];</span><br><span class="line">M[SP]=R2;   <span class="comment">//temp=*ap</span></span><br><span class="line">R1=M[SP+<span class="number">12</span>];</span><br><span class="line">R2=M[R1];</span><br><span class="line">R3=M[SP+<span class="number">8</span>]; </span><br><span class="line">M[R3]=R2;   <span class="comment">//*ap=*bp</span></span><br><span class="line">R1=M[SP];</span><br><span class="line">R2=M[SP+<span class="number">12</span>];</span><br><span class="line">M[R2]=R1;   <span class="comment">//*bp=temp</span></span><br><span class="line">SP=SP+<span class="number">4</span>;</span><br><span class="line">RET;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">┌───────────────┐</span><br><span class="line">│               │	bp</span><br><span class="line">├───────────────┤	</span><br><span class="line">│               │	ap</span><br><span class="line">├───────────────┤</span><br><span class="line">│    saved PC   │	</span><br><span class="line">├───────────────┤</span><br><span class="line">│               │	temp</span><br><span class="line">└───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<ul>
<li>C++版本的SWAP</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="comment">//在swap例子中，c++的引用与c语言使用指针在汇编级别没有任何区别，引用只是在编译器中自动对指针进行解引。</span></span><br></pre></td></tr></table></figure>

<p>引用一旦赋值就不能随便改变指向的变量。例如int x&#x3D;10; int y&#x3D;15; int &amp;z&#x3D;y; 一旦z与y绑定了之后，就不能再让其与x绑定。</p>
<p>而指针可以，所以想要实现链表仍然需要指针。这就是为什么C++中指针仍然有很重要的地位</p>
<p><strong>this指针和对象在内存的存储</strong></p>
<p>C++中结构体和类的唯一区别在于类默认为praite，结构体是public</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">binky</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">dunky</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">char</span> *<span class="title">minky</span><span class="params">(<span class="type">int</span> *z)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> w=*z;</span><br><span class="line">            <span class="keyword">return</span> slinky+<span class="built_in">dunky</span>(winky,winky);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> winky;</span><br><span class="line">    	<span class="type">char</span> *binky;</span><br><span class="line">    	<span class="type">char</span> slinky;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n=<span class="number">17</span>;</span><br><span class="line">binky b;</span><br><span class="line">b.<span class="built_in">minky</span>(&amp;n);</span><br><span class="line"><span class="comment">//binky::minky(&amp;b,&amp;n)实际上汇编代码级别的调用</span></span><br><span class="line"><span class="comment">//如下图所示，传入的This=&amp;b实际上是一个指针，指向类存储的一片区域。</span></span><br><span class="line"><span class="comment">//当在minky函数中调用dunky函数时，默认是使用this-&gt;dunky，即还调用该对象的函数</span></span><br><span class="line"><span class="comment">//也可将binky改为下面这样，那么就意味着minky函数会调用传入对象的dunky函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binky</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">dunky</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">char</span> *<span class="title">minky</span><span class="params">(<span class="type">int</span> *z，binky&amp; d)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> w=*z;</span><br><span class="line">            <span class="keyword">return</span> slinky+d.<span class="built_in">dunky</span>(winky,winky);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> winky;</span><br><span class="line">    	<span class="type">char</span> *binky;</span><br><span class="line">    	<span class="type">char</span> slinky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/07/%E6%96%AF%E5%9D%A6%E7%A6%8F11/1716983234574.png"
                      class="" width="1716983234574"
                >

<p>类中定义static，表示该函数不需要被对象绑定，即在调用该函数的时候不需要this指针的传入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fraction</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">fraction</span>(<span class="type">int</span> n,<span class="type">int</span> d<span class="number">-1</span>);</span><br><span class="line">    ---</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">god</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第十二节：预处理器</title>
    <url>/2024/05/08/%E6%96%AF%E5%9D%A6%E7%A6%8F12/</url>
    <content><![CDATA[<h3 id="第12节：预处理器"><a href="#第12节：预处理器" class="headerlink" title="第12节：预处理器"></a>第12节：预处理器</h3><p><strong>#define</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KWidth  480</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KHeight 720</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KPerameter 2*(KWidth+KHeight)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Width is %d&quot;</span>, KWdith);</span><br><span class="line"><span class="type">int</span> area=KWidth*KHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当预处理器遇到#define，会将两个值存储到一个hashset中。以KWidth为Key，480为值。</span></span><br><span class="line"><span class="comment">//通过预处理器，代码中的KWdith会通过hashset转化为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理器不会进行错误检查</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算VectorNth 即计算第N个元素的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NthElemAddr(base,elemSize,index) ((cahr*)base+index*elemSize)</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> assert(cond) (void)0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> assert(cond) (cond)?((void) 0):fprintf(stderr,<span class="string">&quot;---&quot;</span>),exit(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">VectorNth</span><span class="params">(<span class="built_in">vector</span> *v,<span class="type">int</span> position)</span>&#123;</span><br><span class="line">    assert(position&gt;=<span class="number">0</span>);</span><br><span class="line">    assert(position&lt;v-&gt;loglength);</span><br><span class="line">    <span class="keyword">return</span> NthElemAddr(v-&gt;elems,v-&gt;elemSize,position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面这些情况预处理器会有一些不足：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b)   (((a)&gt;(b))?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max=MAX(fib(<span class="number">100</span>),fact(<span class="number">4000</span>));</span><br><span class="line"><span class="comment">//实际上会被展开为</span></span><br><span class="line"><span class="comment">//int max=(fib(100)&gt;fact(4000))?fib(100):fact(4000)</span></span><br><span class="line"><span class="comment">//fibnacci数列本身计算时间就非常长，使用宏会调用两次fib()，导致性能变差</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max=MAX(m++,n++);</span><br><span class="line"><span class="comment">//int max=((m++)&gt;(n++))?(m++):(n++);</span></span><br><span class="line"><span class="comment">//较大的呢个数将会被自增两次</span></span><br></pre></td></tr></table></figure>

<p>Jerry Cain：由于这些原因，我更喜欢使用static const来定义全局常量而不是#define，大家应该尽量避免预处理的这些特性。</p>
<p><strong>#include</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"><span class="comment">//&lt;&gt;代表了这是一个系统头文件，由编译器提供，使用默认路径找到其位置</span></span><br><span class="line"><span class="comment">//&quot;&quot;的表示，预处理器会将vector.h中的内容写入到此文件中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cc.h</span></span><br><span class="line"><span class="comment">//在头文件定义的时候加入,避免同一个头文件被多次调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _cc_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _cc_h_</span></span><br><span class="line">----</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p>只能#include头文件，因为头文件只能用于声明，不能分配任何的存储空间（除非定义全局共享变量），也不并不产生相应的机器代码。</p>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第十三节：编译与链接</title>
    <url>/2024/05/09/%E6%96%AF%E5%9D%A6%E7%A6%8F13/</url>
    <content><![CDATA[<h3 id="第13节：编译与链接"><a href="#第13节：编译与链接" class="headerlink" title="第13节：编译与链接"></a>第13节：编译与链接</h3><p><strong>complier</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">void</span> *memory=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    assert(memory!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当stdio没有被include的时候，通常的编译器会报错：没有声明printf函数。但GCC不会，GCC会推测这个函数，并在编译和连接时加入。</li>
<li>但当assert.h没有被include的时候，GCC的编译能过，但链接却过不了，因为标准库中没有assert函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多传入参数的例子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">65</span>;</span><br><span class="line">    <span class="type">int</span> length=<span class="built_in">strlen</span>((<span class="type">char</span>*)&amp;num,num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length=%d\n&quot;</span>,length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管strlen多传入了一个参数。但是通过声明骗过了编译器，仍然可以通过编译运行。</span></span><br><span class="line"><span class="comment">//运行时，caller会将65和&amp;num当作参数传入。但对于callee，strlen函数只有一个参数，它只关注&amp;num这一个参数</span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│  <span class="number">65</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  │	num</span><br><span class="line">├───────────────┤	</span><br><span class="line">│               │	length</span><br><span class="line">├───────────────┤</span><br><span class="line">│      <span class="number">65</span>       │	</span><br><span class="line">├───────────────┤   &lt;-----</span><br><span class="line">│     &amp;num      │	</span><br><span class="line">├───────────────┤</span><br><span class="line">│    saved PC   │	</span><br><span class="line">└───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//少传入参数的例子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span><span class="params">(<span class="type">void</span> *v1)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">17</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="built_in">memcmp</span>(&amp;n);</span><br><span class="line">&#125; </span><br><span class="line">C: CALL&lt;memcmp&gt;</span><br><span class="line">  </span><br><span class="line">C++: CALL&lt;memcmp_void_p&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//memcmp的函数原型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span><span class="params">(<span class="type">void</span> *v1,<span class="type">void</span> *v2,<span class="type">int</span> size)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">C++: CALL&lt;memcmp_void_p_void_p_int&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//与上述例子类似，在运行时，对于caller来说，输入的只有&amp;n一个参数。</span></span><br><span class="line"><span class="comment">//但是对于callee来说，memcmp会调用三个参数，会将saved PC上面的三个4byte数据当作输入参数</span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│      <span class="number">17</span>       │	n</span><br><span class="line">├───────────────┤	</span><br><span class="line">│               │	m</span><br><span class="line">├───────────────┤</span><br><span class="line">│      &amp;n       │		</span><br><span class="line">├───────────────┤</span><br><span class="line">│    saved PC   │	</span><br><span class="line">└───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第十四节：程序调试错误</title>
    <url>/2024/05/10/%E6%96%AF%E5%9D%A6%E7%A6%8F14/</url>
    <content><![CDATA[<h3 id="第14节：程序调试错误"><a href="#第14节：程序调试错误" class="headerlink" title="第14节：程序调试错误"></a>第14节：程序调试错误</h3><p><strong>Segmentation  faul :</strong>  </p>
<p>访问程序内存地址之外的地址,通常由于访问了一个空地址造成，即*(NULL)</p>
<p><strong>Bus errors:</strong> </p>
<p>由于未对齐的读或写引起的。之所以被称为总线错误，是因为出现未对齐的内存访问请求时，被堵塞的组件就是地址总线。</p>
<p>内存对齐是由于内存电路的特性决定的，比如DRAM一次输出64Byte到Cache，而Cache一次输出4Byte到32位CPU的寄存器中。也就是对于32位CPU而言内存访问的最小粒度为4Byte，也就是访问0x001和0x003都是访问同一个地址即[0x000-0x003].</p>
<p>为了适应内存这一特点，减少CPU的访存次数。因此提出了内存对齐存放。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/10/%E6%96%AF%E5%9D%A6%E7%A6%8F14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.jpg"
                      class="" title="内存对齐"
                >

<p>如图所示，定义a,b两个char类型变量和c一个int类型变量。</p>
<p>如果不进行内存对齐，变量c会存储在两个内存访问块中，读取或写入c都需要进行两次操作，并且还可能会与a，b产生冲突。如果进行内存对齐那么只需要一次读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问未对齐地址的例子，对于某些机器会产生bus errors，但在目前通用的处理器上不会，只会导致访问效率变低</span></span><br><span class="line"><span class="type">void</span> *vp=---;</span><br><span class="line">*(<span class="type">short</span> *)vp=<span class="number">7</span>;</span><br><span class="line">*(<span class="type">int</span> *)vp=<span class="number">55</span>;</span><br></pre></td></tr></table></figure>

<p> <strong>数组访问溢出:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">short</span> arr[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">        arr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问arr[0]-arr[3]正常，但当i=4，访问的是arr[4]也就是i变量所在地址</span></span><br><span class="line"><span class="comment">//如果是大端系统，那么会将i赋值为0</span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│ <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">4</span> │	i</span><br><span class="line">├───┼───┼───┼───┤</span><br><span class="line">│ <span class="number">0</span> │ <span class="number">0</span> │ <span class="number">0</span> │ <span class="number">0</span> │	arr[<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">├───┴───┴───┴───┤</span><br><span class="line">│               │	why</span><br><span class="line">└───┴───┴───┴───┘</span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">array</span>[i]-=<span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问arr[0]-arr[3]正常，但当i=4，访问的是arr[4]也就是saved PC所在地址</span></span><br><span class="line"><span class="comment">//saved PC会-4，saved PC本来应该指向CALL &lt;foo&gt;函数后面的第一条指令</span></span><br><span class="line"><span class="comment">//-4之后却又指向了CALL &lt;foo&gt;造成了无限递归</span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│    saved PC   │	</span><br><span class="line">├───────────────┤	</span><br><span class="line">│               │	<span class="built_in">array</span>[<span class="number">3</span>]</span><br><span class="line">├───────────────┤</span><br><span class="line">│               │	<span class="built_in">array</span>[<span class="number">2</span>]	</span><br><span class="line">├───────────────┤</span><br><span class="line">│               │	<span class="built_in">array</span>[<span class="number">1</span>]</span><br><span class="line">├───────────────┤</span><br><span class="line">│               │	<span class="built_in">array</span>[<span class="number">0</span>]</span><br><span class="line">├───────────────┤</span><br><span class="line">│               │	i</span><br><span class="line">└───┴───┴───┴───┘</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些只会在比较古老的版本中发生，现代的编译器会通过__stack_chk_guard来保护数组避免溢出</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第十五节：并发编程</title>
    <url>/2024/05/11/%E6%96%AF%E5%9D%A6%E7%A6%8F15/</url>
    <content><![CDATA[<h3 id="第15节：并发编程"><a href="#第15节：并发编程" class="headerlink" title="第15节：并发编程"></a>第15节：并发编程</h3><p>这里的并发性更多是让程序在执行时具有并发性，对于服务器以及UI界面等应用，可以让用户有更好的体验。</p>
<p>而不是针对于多核cpu的并行计算（并行和并发的区别），并行需要物理上拥有多核CPU。 </p>
<p><strong>进程切换：</strong></p>
<p>多线程实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10个代理，每人卖15张票</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numAgents =<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> numTickets =<span class="number">150</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> agent=<span class="number">1</span>;agent&lt;=numAgents;agent++)&#123;</span><br><span class="line">        SellTickets(agent,numTickets/numAgents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SellTickets</span><span class="params">(<span class="type">int</span> agentID,<span class="type">int</span> numTicketToSell)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(numTicketsToSell&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Agent%d sells a ticket&quot;</span>,agentID);</span><br><span class="line">        numTicketToSell--;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Agent%d: All done\n&quot;</span>,agentID);</span><br><span class="line">&#125;</span><br><span class="line">#########################################################################################</span><br><span class="line"><span class="comment">//使用Thread包来进行并发</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numAgents =<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> numTickets =<span class="number">150</span>;</span><br><span class="line">    InitThreadPackage(<span class="literal">false</span>);<span class="comment">//false代表不打印调试信息</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> agent=<span class="number">1</span>;agent&lt;=numAgents;agent++)&#123;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(name,<span class="string">&quot;Agent%d Thread&quot;</span>,agent);</span><br><span class="line">        ThreadNew(name,SellTickets,<span class="number">2</span>,agent,numTickets/numAgents);<span class="comment">//将函数加入各个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    RunAllThread();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SellTickets</span><span class="params">(<span class="type">int</span> agentID,<span class="type">int</span> numTicketToSell)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(numTicketsToSell&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Agent%d sells a ticket&quot;</span>,agentID);</span><br><span class="line">        numTicketToSell--;</span><br><span class="line">        <span class="keyword">if</span>(RandomChance(<span class="number">0.1</span>))ThreadSleep(<span class="number">1000</span>);<span class="comment">//10分之一的概率该线程停止1s</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Agent%d: All done\n&quot;</span>,agentID);</span><br><span class="line">&#125;<span class="comment">//这里的thread相关函数貌似并不是现实中c标准库中的函数，可运行的代码在tk/stanford/thread</span></span><br><span class="line">#########################################################################################</span><br><span class="line"><span class="comment">//十个代理共享150张票</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SellTickets</span><span class="params">(<span class="type">int</span> agent,<span class="type">int</span> *numTicketp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*numTicketsp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Agent%d sells a ticket&quot;</span>,agentID);</span><br><span class="line">        *numTicketp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Agent%d: All done\n&quot;</span>,agentID);</span><br><span class="line">&#125;<span class="comment">//会导致最后一张票被十个人卖，也就是一共卖了159张票</span></span><br><span class="line">#########################################################################################</span><br><span class="line"><span class="comment">//加入信号量来控制线程的访问</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numAgents =<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> numTickets =<span class="number">150</span>;</span><br><span class="line">    Semaphore lock = SemaphoreNOW(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    InitThreadPackage(<span class="literal">false</span>);<span class="comment">//false代表不打印调试信息</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> agent=<span class="number">1</span>;agent&lt;=numAgents;agent++)&#123;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(name,<span class="string">&quot;Agent%d Thread&quot;</span>,agent);</span><br><span class="line">        ThreadNew(name,SellTickets,<span class="number">3</span>,agent,&amp;numTickets,lock);<span class="comment">//将函数加入各个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    RunAllThread();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SellTickets</span><span class="params">(<span class="type">int</span> agent,<span class="type">int</span> *numTicketp,Semaphore lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        SemaphoreWait(lock);</span><br><span class="line">        <span class="keyword">if</span>(*numTicketp==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        (*numTicketp)--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Agent%d sells a ticket&quot;</span>,agentID);</span><br><span class="line">        SemaphoreSignal(lock);</span><br><span class="line">    &#125;</span><br><span class="line">	SemaphoreSignal(lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Agent%d: All done\n&quot;</span>,agentID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间片(time slice)：</p>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第二，三节：数据在内存中的存储格式</title>
    <url>/2024/05/02/%E6%96%AF%E5%9D%A6%E7%A6%8F2,3/</url>
    <content><![CDATA[<h3 id="第2-3节：数据存储格式"><a href="#第2-3节：数据存储格式" class="headerlink" title="第2,3节：数据存储格式"></a>第2,3节：数据存储格式</h3><h4 id="c-c-的数据类型"><a href="#c-c-的数据类型" class="headerlink" title="c&#x2F;c++的数据类型"></a>c&#x2F;c++的数据类型</h4><table>
<thead>
<tr>
<th>bool</th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>1byte</td>
<td>1byte</td>
<td>2byte</td>
<td>4byte</td>
<td>4byte</td>
<td>4byte</td>
<td>8byte</td>
</tr>
</tbody></table>
<ul>
<li>整型数据与字符数据在内存中的存储格式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> s =<span class="number">67</span>;</span><br><span class="line"><span class="type">char</span> ch =s;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt;endl;<span class="comment">//ch = &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浮点数在内存中的存储格式（IEEE754规定）</li>
</ul>
<p><code>[(-1)**Sign ]  *  Mantissa *  [2**(Exp -127)]</code></p>
<table>
<thead>
<tr>
<th>1位</th>
<th>8位</th>
<th>23位</th>
</tr>
</thead>
<tbody><tr>
<td>Sign</td>
<td>Mantissa</td>
<td>Exp</td>
</tr>
</tbody></table>
<ul>
<li><p>以8.25为例：转化为二进制1000.01将整数部分化为1，即1.00001*2exp3</p>
<p>则浮点数为：-1exp0 * 1.00001 * 2exp130</p>
<p>符号位 0，小数00001，指数130&#x3D;0b10000010</p>
<p>则32位浮点数存储8.25的格式为：0 10000010  00001000000000000000000</p>
</li>
<li><p>当Exp为0时，Mantissa的整数位为0。指数为-126</p>
<p>当Exp大于等于1时，Mantissa的的整数位为1。</p>
<p>也就是Exp的最后一位表示了Mantissa有无整数位，这样的目的是为了更高的精度。</p>
<p>同时仍保留-127的格式，如果Exp为0时，指数为-127，那么表示的数就不连续了</p>
<p>1<em>（2</em>*-126）&#x3D;1.1754944e-38</p>
<p>0.9999998807907104<em>（2</em>*-126） &#x3D; 1.1754942e-38</p>
</li>
</ul>
<h4 id="浮点数与整型的转化"><a href="#浮点数与整型的转化" class="headerlink" title="浮点数与整型的转化"></a><strong>浮点数与整型的转化</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">float</span> f =i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,f);<span class="comment">//f =5.000000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//f =5</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> p = *(<span class="type">float</span>*)&amp;o; <span class="comment">//p =7.00649e-45=1/(2**149)+1/(2**147)</span></span><br><span class="line"><span class="comment">//int类型在内存中的数据应为0x00000005=0b0 00000000 00000000000000000000101（小端模式）</span></span><br><span class="line"><span class="comment">//转化为浮点数格式 1.0 * 2exp-117</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.00649e-45 = 1/(2**149)+1/(2**147) 即变为二进制为 1.01 * (2**-147)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0b0 00000000 00000000000000000000101 当exp等于0时 尾数首位不为1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="大小端区别"><a href="#大小端区别" class="headerlink" title="大小端区别"></a><strong>大小端区别</strong></h4><img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/02/%E6%96%AF%E5%9D%A6%E7%A6%8F2,3/07b36950f6f5fc8bc8096f071aafd003.png"
                      class="" title="07b36950f6f5fc8bc8096f071aafd003"
                >

<p>以int 5小端为例子</p>
<table>
<thead>
<tr>
<th>0x7fffffffdfe4</th>
<th>0x7fffffffdfe5</th>
<th>0x7fffffffdfe6</th>
<th>0x7fffffffdfe7</th>
</tr>
</thead>
<tbody><tr>
<td>00000101</td>
<td>00000000</td>
<td>00000000</td>
<td>00000000</td>
</tr>
</tbody></table>
<p>​	进行float强制转换的时候，也会先进行小端读取，0 00000000 00000000000000000000101，再进行位划分</p>
<p>​	也就是浮点数也是按照小端格式存储的（转换再转换，负负得正了）</p>
<h4 id="函数参数与结构体变量的内存存储布局："><a href="#函数参数与结构体变量的内存存储布局：" class="headerlink" title="函数参数与结构体变量的内存存储布局："></a><strong>函数参数与结构体变量的内存存储布局：</strong></h4><p> printf函数：</p>
<p>参数是无限制的，从右到左压栈（最右边参数位于最高地址，先入栈）</p>
<p>struct：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_one</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> code;	<span class="comment">//值都是1</span></span><br><span class="line">    ---</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_two</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> code;	<span class="comment">//值都是2</span></span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规定一个指向结构体base的指针，该指针指向结构体中第一个变量地址即base，只能是1or2</span></span><br><span class="line"><span class="comment">//然后就可以根据code的值来进行强制类型转化，变为type_one或者type_two</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base</span>* <span class="title">ptr</span>;</span></span><br><span class="line">ptr = ;</span><br><span class="line"><span class="keyword">if</span>(*(<span class="type">int</span>*)ptr==<span class="number">1</span>)&#123;(<span class="keyword">struct</span> type_one*)a&#125;<span class="comment">//则可以将ptr作为struct type_one*类型的指针</span></span><br><span class="line"><span class="keyword">else</span>(*(<span class="type">int</span>*)ptr==<span class="number">2</span>)&#123;(<span class="keyword">struct</span> type_two*)a&#125;<span class="comment">//则可以将ptr作为struct type_two*类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IPv4和IPv6的区分就是这样做的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>为什么函数的第一个参数和结构体的第一个变量，都是低地址：</li>
</ul>
<p>因为结构体变量的基地址就是低位，第一个参数与基地址的偏移量为0，其实就是结构体的基地址。</p>
<p>如上图（1）所示，结构体的第一个变量位于低地址，既可以利用基地址来判断结构体类型，从而对不同的ptr进行类型转换来区分type。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/02/%E6%96%AF%E5%9D%A6%E7%A6%8F2,3/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2.png"
                      class="" title="结构体强制转换"
                >

<p>如果第一个参数的地址位于高位，那么就无从知晓这部分与整个结构体变量的基地址的距离了。</p>
<p>如图（2）所示，如果code变量位于高地址，由于base，type_one，type_two的成员不同，导致不同结构体中code变量地址与基地址的距离不相同，没办法对比code，即便强行知道地址对比了code，转换也无法进行（其余变量  没对齐）</p>
<p>因此就可以做上述的强制类型转换</p>
<ul>
<li>为什么结构体变量指向结构体的低地址：</li>
</ul>
<p>只是一个规定，这样所有偏移都是正的。也可也反过来，类似于电路中的正负极（个人理解）</p>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第四，五节：“函数”泛化</title>
    <url>/2024/05/03/%E6%96%AF%E5%9D%A6%E7%A6%8F4,5/</url>
    <content><![CDATA[<h3 id="第4-5节：函数泛化"><a href="#第4-5节：函数泛化" class="headerlink" title="第4,5节：函数泛化"></a>第4,5节：函数泛化</h3><p><strong>泛型指针</strong></p>
<ul>
<li><p>为什么要使用泛型指针</p>
</li>
<li><p>不能解引，因为不知道泛型指针是多少字节。char类指针会指向一个1byte空间的首地址，int会指向4byte空间的首地址。void *只代表指向了一个地址，这个地址无法进行算数运算。如果需要进行算数运算需要使用强制转换比如：</p>
<ul>
<li>​	  void *a; void *b &#x3D; (char *)void *a+1;这里必须使用强制转换。如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *a; </span><br><span class="line"><span class="type">void</span> *b = a + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空指针地址：%d，加一：%d\n&quot;</span>,(<span class="type">char</span>*)a,(<span class="type">char</span>*)b);<span class="comment">//结果为-734501232，-734501231</span></span><br><span class="line"><span class="type">int</span> *c;</span><br><span class="line"><span class="type">int</span> *d = c + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int指针地址：%d，加一：%d\n&quot;</span>,c,d);<span class="comment">//结果为1700604576，1700604580</span></span><br></pre></td></tr></table></figure>

<p>如果不指定强制转换，则会直接对地址进行数值操作（这并不规范）。正确对地址进行操作的方法应该是知道该地址所存储的数据类型，然后+1就相当于将地址指向下一个数据存储的位置，例如int是4，char是1</p>
</li>
<li><p>swap函数泛化</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *ap, <span class="type">int</span> *bp)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *ap;</span><br><span class="line">	*ap = *bp;</span><br><span class="line">	*bp = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛化(错误例子)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span> *vp1, <span class="type">void</span> *vp2)</span>&#123;</span><br><span class="line">	<span class="type">void</span> *temp = *vp2; <span class="comment">//不能声明临时变量为void，也不能对vp2解引</span></span><br><span class="line">	*vp1 = *vp2;</span><br><span class="line">	*vp2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">#########################################################################################</span><br><span class="line"><span class="comment">//泛化(正确例子)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span> *vp1, <span class="type">void</span> *vp2, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="type">char</span> buffer[size];</span><br><span class="line">	<span class="built_in">memcpy</span>(buffer,vp1,size);</span><br><span class="line">	<span class="built_in">memcpy</span>(vp1,vp2,size);</span><br><span class="line">	<span class="built_in">memcpy</span>(vp2,buffer,size);</span><br><span class="line">&#125;<span class="comment">//传入的是地址，交换的是地址中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法1</span></span><br><span class="line"><span class="type">int</span> X=<span class="number">17</span>,y=<span class="number">37</span>;</span><br><span class="line">swap(&amp;x, &amp;y, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法2</span></span><br><span class="line"><span class="comment">//字符&quot;Fred&quot;,&quot;Wllma&quot;在堆区</span></span><br><span class="line"><span class="type">char</span> *husband = strdup(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line"><span class="type">char</span> *wife = strdup(<span class="string">&quot;Wllma&quot;</span>);</span><br><span class="line"><span class="comment">//交换husband和wife指针变量所指向的地址</span></span><br><span class="line">swap(&amp;husband, &amp;wife, <span class="keyword">sizeof</span>(<span class="type">char</span>*))</span><br><span class="line"><span class="comment">//交换husband和wife指针变量所指向地址的内容的前四byte</span></span><br><span class="line">swap(husband, wife, <span class="keyword">sizeof</span>(<span class="type">char</span>*))<span class="comment">//如果是32位机，char*为4byte</span></span><br><span class="line"><span class="comment">//交换“Fred”与wife指针变量所指向的地址，结果会乱码</span></span><br><span class="line">swap(husband, &amp;wife, <span class="keyword">sizeof</span>(<span class="type">char</span>*))</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/03/%E6%96%AF%E5%9D%A6%E7%A6%8F4,5/1709521442524.png"
                      class="" width="1709521442524"
                >

<ul>
<li>lsearch函数泛化(线性搜索)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lsearch</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> <span class="built_in">array</span>[],<span class="type">int</span> siez)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i]==key)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里函数的参数中使用的函数指针，函数指针的声明如下：</span></span><br><span class="line"><span class="comment">//return_type (*pointer_name)(parameter_type1, parameter_type2, ...);</span></span><br><span class="line"><span class="comment">//return_type 是函数的返回类型；</span></span><br><span class="line"><span class="comment">//pointer_name 是指针变量的名称；</span></span><br><span class="line"><span class="comment">//parameter_type1, parameter_type2, ... 是函数的参数类型。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">lsearch</span><span class="params">(<span class="type">void</span> *key,<span class="type">void</span> *base,<span class="type">int</span> n,<span class="type">int</span> elemSize,<span class="type">int</span>(*cmpfn)(<span class="type">void</span> *,<span class="type">void</span> *))</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">void</span> *elemAddr = (<span class="type">char</span>*)base +i*elemSize;</span><br><span class="line">        <span class="keyword">if</span>(cmpfn(key,elemAddr)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> elemAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方法(int类型)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intCmp</span><span class="params">(<span class="type">void</span> *elem1,<span class="type">void</span> *elem2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ip1=elem1;</span><br><span class="line">    <span class="type">int</span> *ip2=elem2;</span><br><span class="line">    <span class="keyword">return</span> *ip1-*ip2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> number=<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> *found=lsearch(&amp;number,<span class="built_in">array</span>,<span class="number">6</span>,</span><br><span class="line">                   <span class="keyword">sizeof</span>(<span class="type">int</span>),intCmp);<span class="comment">//直接传入函数名，因为函数名就代表了函数的地址</span></span><br><span class="line"><span class="comment">//调用方法（char *类型）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCmp</span><span class="params">(<span class="type">void</span> *vp1,<span class="type">void</span> *vp2)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *s1 = *(<span class="type">char</span> **)vp1;<span class="comment">// 这里的强制转换加了**是为了逻辑通畅，实际上char*=char**，编译器会检查</span></span><br><span class="line">    <span class="type">char</span> *s2 = *(<span class="type">char</span> **)vp2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(s1,s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *notes[]=&#123;<span class="string">&quot;Ab&quot;</span>,<span class="string">&quot;F#&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;Gb&quot;</span>,<span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> *favoriteNote=<span class="string">&quot;Eb&quot;</span>;</span><br><span class="line"><span class="type">char</span> **found=lsearch(&amp;favoriteNote,notes,<span class="number">5</span>,</span><br><span class="line">                     <span class="keyword">sizeof</span>(<span class="type">char</span>*),StrCmp);</span><br></pre></td></tr></table></figure>

<ul>
<li>bsearch函数泛化(二分搜索){作业}</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(<span class="type">void</span> *key,<span class="type">void</span> *base,<span class="type">int</span> n,<span class="type">int</span> elemSize,<span class="type">int</span>(*cmpfn)(<span class="type">void</span> *,<span class="type">void</span> *))</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第八，九节：堆栈的内存分配</title>
    <url>/2024/05/05/%E6%96%AF%E5%9D%A6%E7%A6%8F8,9/</url>
    <content><![CDATA[<h3 id="第8-9节：堆栈内存分配"><a href="#第8-9节：堆栈内存分配" class="headerlink" title="第8,9节：堆栈内存分配"></a>第8,9节：堆栈内存分配</h3><p>（这节将的都是最一些远古时期计算机管理内存的方法，现代计算机肯定有更好更复杂的方法，只学分配的机制和其中的思想就够了，不用纠结他写的伪代码和具体方案）</p>
<ul>
<li>堆的分配</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/05/%E6%96%AF%E5%9D%A6%E7%A6%8F8,9/1714204618085.png"
                      class="" width="1714204618085"
                >

<p>​	每个被分配出去的内存块都有一个头部，记录了内存块的大小，某些还会记录后面的内存块是否空闲</p>
<p>​	使用链表来记录堆内的空闲空间。该链表由堆的开头和结尾组成，中间节点记录了当前空闲空间的头地址，并且指向了下一个空闲空间的地址。当调用mallco时就会遍历这个链表来寻址合适的空间来分配。当调用free的时候就相当于在链表插入新的节点，当有连续的空闲空间时，节点有时候也会合并{这个链表应该也会记录空间空间的大小}</p>
<ul>
<li><p>堆内存压缩</p>
<p>​	mallco函数必须分配连续的内存空间，但频繁的mallco和free内存会导致堆内存中存在大量的分散小内存碎片。堆内存压缩的目标是通过整理堆内存中的内存块，将分散的小块内存合并成更大的连续内存块，从而减少碎片化。这样做的好处是可以提高内存的利用率，避免由于碎片化导致无法满足大内存分配请求的情况。</p>
<p>​	Mac OS 7.6通过handle来对堆内存进行压缩，即通过二级指针。如图所示，操作系统返回给用户的实际是一个指针，指向列表中指针的地址，而这个表中的指针又真正指向内存中的一片区域</p>
<p>​	这样做的好处在于，当需要对堆内存进行压缩的时候，只需要修改列表中指针的指向就可以了，而不需要去修改用户端获取的指针。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/2024/05/05/%E6%96%AF%E5%9D%A6%E7%A6%8F8,9/1714294645239.png"
                      class="" width="1714294645239"
                ></li>
</ul>
<p>​			在操作时，有时候不希望操作系统进行压缩可以使用Handlelock来保护这块内存，类似于线程锁（见并发编程）</p>
<ul>
<li><p>汇编语言  </p>
<ul>
<li>for循环例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">array</span>[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i--;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//伪汇编表达</span></span><br><span class="line"><span class="number">0</span>:M[R1]=<span class="number">0</span></span><br><span class="line">    <span class="comment">//i=0</span></span><br><span class="line"><span class="number">1</span>:R2=M[R1]</span><br><span class="line"><span class="number">2</span>:BGE R2,<span class="number">4</span>,PC+<span class="number">40</span></span><br><span class="line">    <span class="comment">//i&lt;4</span></span><br><span class="line"><span class="number">3</span>:R3=M[R1]</span><br><span class="line"><span class="number">4</span>:R4=R3*<span class="number">4</span></span><br><span class="line"><span class="number">5</span>:R5=R1+<span class="number">4</span></span><br><span class="line"><span class="number">6</span>:R6=R4+R5</span><br><span class="line"><span class="number">7</span>:M[R6]=<span class="number">0</span></span><br><span class="line">    <span class="comment">//array[i]=0</span></span><br><span class="line"><span class="number">8</span>:R2=M[R1]*</span><br><span class="line"><span class="number">9</span>:R2=R2+<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:M[R1]=R2</span><br><span class="line">    <span class="comment">//i++</span></span><br><span class="line"><span class="number">11</span>:JMP PC<span class="number">-40</span></span><br><span class="line">    [] <span class="comment">//i-- 课程没有给出，大概就是R2=M[R1],R2=R2-1,M[R1]=R2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//学生提问：为什么要跳回到10行代码之前,即第1行</span></span><br><span class="line">    <span class="comment">//回答：养成写上下文无关代码的习惯，虽然这里的R2恰好是i的值，这也是for循环的统一规律，但为了保证更复杂的情况，还是需要养成习惯。</span></span><br><span class="line">    <span class="comment">//think：现代的编译器应该会对这些进行优化，不过自己写的时候这样更能避免出错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结构体例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">pi</span>;</span><span class="comment">//R1存储了指向结构体低地址的一个指针</span></span><br><span class="line">pi.num=<span class="number">22</span>;	<span class="comment">//M[R1]=22</span></span><br><span class="line">pi.denom=<span class="number">7</span>;	<span class="comment">//M[R1+4]=7</span></span><br><span class="line"></span><br><span class="line">((<span class="keyword">struct</span> fraction)&amp;pi.denom)-&gt;denom=<span class="number">451</span>;	<span class="comment">//M[R1+8]=451</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个例子表明了对于机器以及汇编级别来说，并不关心数据的类型，只关心数据本身以及数据的地址和大小</span></span><br><span class="line">	<span class="comment">//强制类型转换只是针对编译器来设计的伎俩</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里是在栈上申请空间，mallco是在堆上，不过存储形式没有什么区别，只是位置不同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指令编码</p>
<p>讲的并不详细，直接去看riscv的编码格式就可以</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>编程语言中符号的英文读法</title>
    <url>/2024/06/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%8B%B1%E6%96%87%E8%AF%BB%E6%B3%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>符号</th>
<th>怎么读</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>pound</td>
<td>宏定义</td>
</tr>
<tr>
<td>*</td>
<td>star</td>
<td>指针</td>
</tr>
<tr>
<td>&amp;</td>
<td>ampersand</td>
<td>取址</td>
</tr>
<tr>
<td>&amp;</td>
<td>reference</td>
<td>引用</td>
</tr>
<tr>
<td>&amp;</td>
<td>bitwise and</td>
<td>与计算</td>
</tr>
<tr>
<td>{}</td>
<td>curly brackets</td>
<td>花括号</td>
</tr>
<tr>
<td>()</td>
<td>round brackets</td>
<td>圆括号</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>angle brackets</td>
<td>尖括号</td>
</tr>
<tr>
<td>[]</td>
<td>square brackets</td>
<td>方括号</td>
</tr>
<tr>
<td>:</td>
<td>colon</td>
<td>冒号</td>
</tr>
<tr>
<td>;</td>
<td>semicolon</td>
<td>分号</td>
</tr>
<tr>
<td>‘</td>
<td>single quote</td>
<td>单引号</td>
</tr>
<tr>
<td>“</td>
<td>double quote</td>
<td>双引号</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
<td>大于</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>equals</td>
<td>等于</td>
</tr>
<tr>
<td>%</td>
<td>modulo</td>
<td>取余</td>
</tr>
<tr>
<td>!</td>
<td>not</td>
<td>取反</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>slash</td>
<td>正斜杠</td>
</tr>
<tr>
<td>\</td>
<td>back slash</td>
<td>反斜杠</td>
</tr>
<tr>
<td>,</td>
<td>comma</td>
<td>逗号</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>斯坦福编程范式公开课第六，七节：“方法”泛化</title>
    <url>/2024/05/04/%E6%96%AF%E5%9D%A6%E7%A6%8F6,7/</url>
    <content><![CDATA[<h3 id="第6-7节：method泛化"><a href="#第6-7节：method泛化" class="headerlink" title="第6,7节：method泛化"></a>第6,7节：method泛化</h3><p>函数与method的区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack.h</span></span><br><span class="line"><span class="keyword">typedef</span> sturct&#123;</span><br><span class="line">    <span class="type">int</span> *elems;</span><br><span class="line">    <span class="type">int</span> loglength;</span><br><span class="line">    <span class="type">int</span> alloclength;</span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackNew</span><span class="params">(<span class="built_in">stack</span> *s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">StackPop</span><span class="params">(<span class="built_in">stack</span> *s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackNew</span><span class="params">(<span class="built_in">stack</span> *s)</span>&#123;</span><br><span class="line">    s-&gt;loglength=<span class="number">0</span>;</span><br><span class="line">    s-&gt;alloclength=<span class="number">4</span>;</span><br><span class="line">    s-&gt;elems=<span class="built_in">malloc</span>(<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    assert(s-&gt;elems!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;elems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;loglength==s-&gt;alloclength)&#123;</span><br><span class="line">        s-&gt;alloclength*=<span class="number">2</span>;</span><br><span class="line">        s-&gt;elems=<span class="built_in">realloc</span>(s-&gt;elems,alloclength);</span><br><span class="line">        assert(s-&gt;elems!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;elems[s-&gt;loglength]=value;</span><br><span class="line">    s-&gt;loglength++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">StackPop</span><span class="params">(<span class="built_in">stack</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(s-&gt;loglength&gt;<span class="number">0</span>);</span><br><span class="line">    s-&gt;loglength--;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;elems[s-&gt;loglength];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack.h(泛化)</span></span><br><span class="line"><span class="keyword">typedef</span> sturct&#123;</span><br><span class="line">    <span class="type">void</span> *elems;</span><br><span class="line">    <span class="type">int</span> elemSize;</span><br><span class="line">    <span class="type">int</span> loglength;</span><br><span class="line">    <span class="type">int</span> alloclength;</span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackNew</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">int</span> elemSize)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">void</span> *elemAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">void</span> *elemAddr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackNew</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">int</span> elemSize)</span>&#123;</span><br><span class="line">    assert(s-&gt;elemSize&gt;<span class="number">0</span>);</span><br><span class="line">    s-&gt;loglength=<span class="number">0</span>;</span><br><span class="line">    s-&gt;alloclength=<span class="number">4</span>;</span><br><span class="line">    s-&gt;elemSize=elemSzie;</span><br><span class="line">    s-&gt;elems=<span class="built_in">malloc</span>(<span class="number">4</span>*elemSize);</span><br><span class="line">    assert(s-&gt;elems!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(s-&gt;elems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">StackGrow</span><span class="params">(<span class="built_in">stack</span> *s)</span>&#123;<span class="comment">//static代表仅在此文件内被调用</span></span><br><span class="line">    s-&gt;alloclength*=<span class="number">2</span>;</span><br><span class="line">    s-&gt;elems=<span class="built_in">realloc</span>(s-&gt;elems,s-&gt;alloclength*s-&gt;elemsSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">void</span> *elemAddr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;loglength==s-&gt;alloclength)&#123;</span><br><span class="line">        StackGrow(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *target=(<span class="type">char</span>*)s-&gt;elems+(s-&gt;loglenth*s-&gt;elemSzie);</span><br><span class="line">    <span class="built_in">memcpy</span>(target,elemAddr,s-&gt;elemSize);</span><br><span class="line">    s-&gt;loglength++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">void</span> *elemAddr)</span>&#123;</span><br><span class="line">    <span class="type">void</span> *source=(<span class="type">char</span> *)s-&gt;elems+(s-&gt;loglength<span class="number">-1</span>)*s-&gt;elemSize;</span><br><span class="line">    <span class="built_in">memcpy</span>(elemAddr,source,s-&gt;elemSize);</span><br><span class="line">    s-&gt;loglength--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* friends[]=&#123;<span class="string">&quot;Ai&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Carl&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">stack</span> stringStack;</span><br><span class="line">    StackNew(&amp;stringStack,<span class="keyword">sizeof</span>(<span class="type">char</span>*));<span class="comment">//要存的是指针数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">char</span>* copy=strdup(friends[i]);<span class="comment">//为什么要使用copy</span></span><br><span class="line">        StackPush(&amp;stringStack,&amp;copy );<span class="comment">//存储的实际是一个指向字符串的一个指针</span></span><br><span class="line">            				<span class="comment">//Push函数接收的应该是需要存储数据的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        StackPop(&amp;stringStack,&amp;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name);<span class="comment">//printf的%d需要传入的是指针</span></span><br><span class="line">        <span class="built_in">free</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    StackDispose(&amp;stringStack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的调用会存在一个问题，当栈中传入的是指针类型变量时，我们使用stackDispose()函数只是将该变量所在的内存空间释放了，但是并没有释放掉该变量所指向的内存空间。（即strdup函数所申请的呢一块空间）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升级部分函数以支持对函数</span></span><br><span class="line"><span class="keyword">typedef</span> sturct&#123;</span><br><span class="line">    <span class="type">void</span> *elems;</span><br><span class="line">    <span class="type">int</span> elemSize;</span><br><span class="line">    <span class="type">int</span> loglength;</span><br><span class="line">    <span class="type">int</span> alloclength;</span><br><span class="line">    <span class="type">void</span> (*freefn)(<span class="type">void</span>*));</span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackNew</span><span class="params">(<span class="built_in">stack</span> *s,<span class="type">int</span> elemSize,<span class="type">void</span>(*freefn)(<span class="type">void</span>*))</span>&#123;</span><br><span class="line">    assert(s-&gt;elemSize&gt;<span class="number">0</span>);</span><br><span class="line">    s-&gt;loglength=<span class="number">0</span>;</span><br><span class="line">    s-&gt;alloclength=<span class="number">4</span>;</span><br><span class="line">    s-&gt;elemSize=elemSzie;</span><br><span class="line">    s-&gt;elems=<span class="built_in">malloc</span>(<span class="number">4</span>*elemSize);</span><br><span class="line">    s-&gt;freenfn=freefn;</span><br><span class="line">    assert(s-&gt;elems!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;freefn!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s-&gt;loglength;i++)&#123;</span><br><span class="line">        s-&gt;freefn((<span class="type">char</span>*)s-&gt;elems+i*s-&gt;elemSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;elems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StringFree</span><span class="params">(<span class="type">void</span> *elem)</span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(*(<span class="type">char</span>**)elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">stack</span> stringStack</span><br><span class="line"><span class="title function_">stackNew</span><span class="params">(&amp;stringStack,<span class="keyword">sizeof</span>(<span class="type">char</span> *),StringFree)</span>;</span><br><span class="line">---与上述一样</span><br><span class="line">   </span><br><span class="line"><span class="comment">//为什么不在stackPop()函数返回之前就调用freefn呢，因为这时候pop出来的元素还在指向字符串，不能</span></span><br></pre></td></tr></table></figure>

<p>单引号只能包含单个字符，这里的AI,Bob需要使用双引号””</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设有一个大小为x数组，希望将前a位移到最后面去，然后将剩余的x-a个数向前移a位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">void</span>* front,<span class="type">void</span>* middle,<span class="type">void</span>* end)</span>&#123;</span><br><span class="line">	<span class="type">int</span> frontSize=(<span class="type">char</span>*)middle-(<span class="type">char</span>*)front;</span><br><span class="line">    <span class="type">int</span> backSize=(<span class="type">char</span>*)end-(<span class="type">char</span>*)middle;</span><br><span class="line">    <span class="type">char</span> buffer[frontSize];</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer,front,frontSize);</span><br><span class="line">    memmove(front,middle,backSize);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span>*)end-frontSize,buffer,frontSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base,<span class="type">int</span> size,<span class="type">int</span> elemSize,<span class="type">int</span>(*cmpfn)(<span class="type">void</span>*))</span></span><br><span class="line"><span class="comment">//在linux中使用man qsort可以了解更多信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>结构体指针和结构体变量的区别</p>
<p>w</p>
<ul>
<li><p>c++中类的动态分配和静态分配(与结构体类似)</p>
<p>静态：MyClass obj1(5);</p>
<p>动态：MyClass* obj2 &#x3D; new MyClass(10);</p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
